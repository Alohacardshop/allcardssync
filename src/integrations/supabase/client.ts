// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Use environment variables with fallbacks for Lovable compatibility
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://dmpoandoydaqxhzdjnmk.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtcG9hbmRveWRhcXhoemRqbm1rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ0MDU5NDMsImV4cCI6MjA2OTk4MTk0M30.WoHlHO_Z4_ogeO5nt4I29j11aq09RMBtNug8a5rStgk";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// TCG Database Connection (configurable via environment)
const TCG_URL = import.meta.env.VITE_TCG_URL || "https://dhyvufggodqkcjbrjhxk.supabase.co";
const TCG_ANON_KEY = import.meta.env.VITE_TCG_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRoeXZ1Zmdnb2Rxa2NqYnJqaHhrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY1MDIyOTcsImV4cCI6MjA3MjA3ODI5N30.0GncadcSHVbthqyubXLiBflm44sFEz_izfF5uF-xEvs";

export const tcgSupabase = createClient(TCG_URL, TCG_ANON_KEY, {
  auth: {
    persistSession: false,
    storage: undefined, // Disable storage to avoid conflicts
    autoRefreshToken: false,
    detectSessionInUrl: false,
  }
});

// External TCG database (read-only) - configurable via environment
const EXTERNAL_URL = import.meta.env.VITE_EXTERNAL_TCG_URL || 'https://ljywcyhnpzqgpowwrpre.supabase.co';
const EXTERNAL_ANON_KEY = import.meta.env.VITE_EXTERNAL_TCG_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxqeXdjeWhucHpxZ3Bvd3dycHJlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcwOTI2ODIsImV4cCI6MjA3MjY2ODY4Mn0.Hq0zKaJaWhNR4WLnqM4-UelgRFEPEFi_sk6p7CzqSEA';

export const tcgLjyClient = createClient(EXTERNAL_URL, EXTERNAL_ANON_KEY, {
  auth: {
    persistSession: false, // Read-only client, no session needed
    storage: undefined, // Disable storage to avoid conflicts
    autoRefreshToken: false,
    detectSessionInUrl: false,
  }
});

// TCG Database Types
export interface Game {
  id: string;
  name: string;
  slug: string;
  logo_url?: string;
  description?: string;
}

export interface Set {
  id: string;
  name: string;
  code: string;
  game_id: string;
  release_date?: string;
  card_count?: number;
}

export interface Card {
  id: string;
  name: string;
  set_id: string;
  justtcg_card_id: string;
  rarity?: string;
  image_url?: string;
  type_line?: string;
  mana_cost?: string;
  oracle_text?: string;
}

export interface Variant {
  id: string;
  card_id: string;
  condition: string;
  printing: string;
  price_cents: number;
  market_price_cents?: number;
}

export interface SearchResult {
  id: string;
  name: string;
  set_name: string;
  game_name: string;
  number?: string;
  rarity?: string;
  image_url?: string;
  rank: number;
}

export interface PopularCard {
  id: string;
  name: string;
  set_name: string;
  game_name: string;
  image_url?: string;
  avg_price_cents: number;
  variant_count: number;
  rarity?: string; // Added optional rarity field
}

export interface PricingResponse {
  success: boolean
  cardId: string
  refreshed: boolean
  requestPayload?: any
  error?: string
  variants: Array<{
    id: string
    sku?: string
    condition: string
    printing: string
    pricing: {
      price_cents: number | null
      market_price_cents: number | null
      low_price_cents: number | null
      high_price_cents: number | null
    }
    // Legacy format for compatibility
    price_cents?: number
    market_price_cents?: number
    is_available: boolean
    last_updated: string
    card: {
      name: string
      image_url: string
      set_name: string
      game_name: string
    }
  }>
}

// Legacy interface for compatibility
export interface PricingData extends PricingResponse {}

// Type definitions for external database
export interface ExternalGame {
  id: string;
  name: string;
  slug?: string;
}

export interface ExternalSet {
  id: string;
  name: string;
  game_id?: string;
  release_date?: string;
}

export interface ExternalCard {
  id: string;
  name: string;
  number?: string;
  rarity?: string;
  image_url?: string;
  game_id?: string;
  set_id?: string;
  // Joined data
  set_name?: string;
  game_name?: string;
}

export interface ExternalPrice {
  id: string;
  card_id: string;
  price_cents?: number;
  market_price_cents?: number;
  low_price_cents?: number;
  high_price_cents?: number;
  created_at: string;
}

export interface SearchFilters {
  gameId?: string;
  setId?: string;
  rarity?: string;
  page?: number;
  pageSize?: number;
}

export function formatPrice(cents: number | null): string {
  if (!cents) return 'N/A'
  return `$${(cents / 100).toFixed(2)}`
}

export function findVariant(response: PricingResponse, condition: string, printing: string) {
  return response.variants.find(v => 
    v.condition === condition && v.printing === printing
  )
}

export async function updateCardPricing(
  cardId: string, 
  condition: string = 'near_mint', 
  printing: string = 'normal'
): Promise<PricingResponse> {
  try {
    const { data, error } = await tcgSupabase.functions.invoke('get-card-pricing', {
      body: {
        cardId,
        condition,
        printing,
        refresh: true
      }
    })

    if (error) {
      // Handle 404 as "no pricing available"
      if (error.message?.includes('404') || error.message?.includes('No variants found')) {
        return {
          success: false,
          cardId,
          refreshed: true,
          variants: []
        }
      }
      throw error
    }
    return data
  } catch (error) {
    console.error('Pricing update failed:', error)
    // Fallback to cached data
    return getCachedPricing(cardId, condition, printing)
  }
}

// Read cached pricing from TCG DB (default path)
export async function getCachedPricingViaDB(
  cardId: string, 
  condition: string = 'near_mint', 
  printing: string = 'normal',
  variantId?: string
): Promise<PricingResponse> {
  try {
    if (variantId) {
      // Read specific variant by ID
      const { data: variant, error } = await tcgSupabase
        .from('catalog_v2.variants')
        .select('id, condition, printing, sku, price, market_price, low_price, mid_price, high_price, updated_at, card_id')
        .eq('id', variantId)
        .single();

      if (error || !variant) {
        return {
          success: false,
          cardId,
          refreshed: false,
          variants: [],
          error: 'Variant not found'
        };
      }

      // Get card info
      const { data: card } = await tcgSupabase
        .from('catalog_v2.cards')
        .select('name, image_url, set_id, game')
        .eq('id', variant.card_id)
        .single();

      // Get set name if available
      let setName = '';
      if (card?.set_id) {
        const { data: set } = await tcgSupabase
          .from('catalog_v2.sets')
          .select('name')
          .eq('id', card.set_id)
          .single();
        setName = set?.name || '';
      }

      return {
        success: true,
        cardId,
        refreshed: false,
        variants: [{
          id: variant.id,
          sku: variant.sku,
          condition: variant.condition,
          printing: variant.printing,
          pricing: {
            price_cents: variant.price ? Math.round(variant.price * 100) : null,
            market_price_cents: variant.market_price ? Math.round(variant.market_price * 100) : null,
            low_price_cents: variant.low_price ? Math.round(variant.low_price * 100) : null,
            high_price_cents: variant.high_price ? Math.round(variant.high_price * 100) : null
          },
          is_available: true,
          last_updated: variant.updated_at,
          card: {
            name: card?.name || '',
            image_url: card?.image_url || '',
            set_name: setName,
            game_name: card?.game || ''
          }
        }]
      };
    } else {
      // Read by card ID, condition, printing
      const { data: variants, error } = await tcgSupabase
        .from('catalog_v2.variants')
        .select('id, condition, printing, sku, price, market_price, low_price, mid_price, high_price, updated_at, card_id')
        .eq('card_id', cardId)
        .eq('condition', condition)
        .eq('printing', printing);

      if (error) {
        return {
          success: false,
          cardId,
          refreshed: false,
          variants: [],
          error: error.message
        };
      }

      // Get card info for display
      const { data: card } = await tcgSupabase
        .from('catalog_v2.cards')
        .select('name, image_url, set_id, game')
        .eq('id', cardId)
        .single();

      // Get set name if available
      let setName = '';
      if (card?.set_id) {
        const { data: set } = await tcgSupabase
          .from('catalog_v2.sets')
          .select('name')
          .eq('id', card.set_id)
          .single();
        setName = set?.name || '';
      }

      return {
        success: true,
        cardId,
        refreshed: false,
        variants: (variants || []).map(variant => ({
          id: variant.id,
          sku: variant.sku,
          condition: variant.condition,
          printing: variant.printing,
          pricing: {
            price_cents: variant.price ? Math.round(variant.price * 100) : null,
            market_price_cents: variant.market_price ? Math.round(variant.market_price * 100) : null,
            low_price_cents: variant.low_price ? Math.round(variant.low_price * 100) : null,
            high_price_cents: variant.high_price ? Math.round(variant.high_price * 100) : null
          },
          is_available: true,
          last_updated: variant.updated_at,
          card: {
            name: card?.name || '',
            image_url: card?.image_url || '',
            set_name: setName,
            game_name: card?.game || ''
          }
        }))
      };
    }
  } catch (error) {
    console.error('Error reading cached pricing from DB:', error);
    return {
      success: false,
      cardId,
      refreshed: false,
      variants: [],
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

// Manual refresh - calls TCG DB edge function
export async function updateVariantPricing(
  cardId: string,
  condition: string = 'near_mint',
  printing: string = 'normal',
  variantId?: string
): Promise<PricingResponse> {
  try {
    const { data, error } = await tcgSupabase.functions.invoke('get-card-pricing', {
      body: {
        cardId,
        condition,
        printing,
        variantId,
        refresh: true
      }
    });

    if (error) {
      // Handle "Card not found" gracefully
      if (error.message?.includes('Card not found') || error.message?.includes('404')) {
        return {
          success: false,
          cardId,
          refreshed: true,
          variants: [],
          error: 'Card not found',
          requestPayload: { cardId, condition, printing, variantId, refresh: true }
        };
      }
      
      return {
        success: false,
        cardId,
        refreshed: true,
        variants: [],
        error: error.message,
        requestPayload: { cardId, condition, printing, variantId, refresh: true }
      };
    }

    return {
      ...data,
      requestPayload: { cardId, condition, printing, variantId, refresh: true }
    };
  } catch (error) {
    console.error('Error updating variant pricing:', error);
    return {
      success: false,
      cardId,
      refreshed: true,
      variants: [],
      error: error instanceof Error ? error.message : 'Unknown error',
      requestPayload: { cardId, condition, printing, variantId, refresh: true }
    };
  }
}

export async function getCachedPricing(
  cardId: string, 
  condition?: string, 
  printing?: string
): Promise<PricingResponse> {
  const { data, error } = await tcgSupabase.functions.invoke('get-card-pricing', {
    body: {
      cardId,
      condition,
      printing,
      refresh: false
    }
  })

  if (error) {
    // Handle 404 as "no pricing available"
    if (error.message?.includes('404') || error.message?.includes('No variants found')) {
      return {
        success: false,
        cardId,
        refreshed: false,
        variants: []
      }
    }
    throw error
  }
  return data
}

// Get pricing by variant ID directly
export async function updateVariantPricingById(variantId: string): Promise<PricingResponse> {
  try {
    const { data, error } = await tcgSupabase.functions.invoke('get-card-pricing', {
      body: {
        variantId,
        refresh: true
      }
    })

    if (error) throw error
    return data
  } catch (error) {
    console.error('Variant pricing update failed:', error)
    throw error
  }
}

// Get pricing without refresh - calls TCG DB edge function
export async function getVariantPricing(
  cardId: string,
  condition: string = 'near_mint',
  printing: string = 'normal',
  variantId?: string
): Promise<PricingResponse> {
  try {
    const { data, error } = await tcgSupabase.functions.invoke('get-card-pricing', {
      body: {
        cardId,
        condition,
        printing,
        variantId,
        refresh: false
      }
    });

    if (error) {
      // Handle "Card not found" gracefully
      if (error.message?.includes('Card not found') || error.message?.includes('404')) {
        return {
          success: false,
          cardId,
          refreshed: false,
          variants: [],
          error: 'Card not found',
          requestPayload: { cardId, condition, printing, variantId, refresh: false }
        };
      }

      return {
        success: false,
        cardId,
        refreshed: false,
        variants: [],
        error: error.message,
        requestPayload: { cardId, condition, printing, variantId, refresh: false }
      };
    }

    return {
      ...data,
      requestPayload: { cardId, condition, printing, variantId, refresh: false }
    };
  } catch (error) {
    console.error('Error getting variant pricing:', error);
    return {
      success: false,
      cardId,
      refreshed: false,
      variants: [],
      error: error instanceof Error ? error.message : 'Unknown error',
      requestPayload: { cardId, condition, printing, variantId, refresh: false }
    };
  }
}

// Fetch card variants directly from TCG DB for condition/printing options
export async function fetchCardVariants(cardId: string): Promise<{conditions: string[], printings: string[]}> {
  try {
    const { data: variants, error } = await tcgSupabase
      .from('variants')
      .select('condition, printing')
      .eq('card_id', cardId);

    if (error) {
      console.error('Error fetching card variants:', error);
      return { conditions: [], printings: [] };
    }

    const conditions = [...new Set(variants?.map(v => v.condition).filter(Boolean))];
    const printings = [...new Set(variants?.map(v => v.printing).filter(Boolean))];

    return { conditions, printings };
  } catch (error) {
    console.error('Error fetching card variants:', error);
    return { conditions: [], printings: [] };
  }
}